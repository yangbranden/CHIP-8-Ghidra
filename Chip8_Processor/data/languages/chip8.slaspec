define endian=big;
define alignment=2;

## Address spaces
# CHIP-8 address space is 4096 bytes, so 2-byte addresses
define space ram        type=ram_space      size=2  default;
define space register   type=register_space size=1;

## Registers
# General purpose registers (16 8-bit)
define register offset=0x00 size=1 [ V0 V1 V2 V3 V4 V5 V6 V7 V8 V9 VA VB VC VD VE VF ];
# 16-bit registers (stack pointer, program counter, index register)
define register offset=0x10 size=2 [ SP PC I ];
# Other 8-bit registers (timer registers)
define register offset=0x14 size=1 [ DT ST ];


## Instruction format
# All CHIP-8 instructions are 2 bytes
define token instr (16)
    opcode_full = (0,15)        # The full 16-bit instruction (some instructions interpret all)
    opcode      = (12,15)       # Opcode: Highest 4 bits
    nnn         = (0,11)        # nnn or addr: A 12-bit value, the lowest 12 bits of the instruction
    n           = (0,3)         # n or nibble: A 4-bit value, the lowest 4 bits of the instruction
    x           = (8,11)        # x: A 4-bit value, the lower 4 bits of the high byte of the instruction
    y           = (4,7)         # y: A 4-bit value, the upper 4 bits of the low byte of the instruction
    kk          = (0,7)         # kk or byte: An 8-bit value, the lowest 8 bits of the instruction
;

## Additional context
# Vx and Vy are used to refer to registers
attach variables [ Vx Vy ] [ V0 V1 V2 V3 V4 V5 V6 V7 V8 V9 VA VB VC VD VE VF ];

## Custom operations
define pcodeop rand;            # generate random number 0-255 (Ghidra doesn't need to know)
define pcodeop get_key_press;   # get current key press
define pcodeop draw_sprite;     # draw sprite onto the screen (basically handle logic for DRW instruction)

## Macros
macro set_flag(value) {
    VF = value:1;
}


## Instructions
# Following Cowgod's specification

# 0nnn - SYS addr; Jump to a machine code routine at addr
:SYS addr is opcode=0x0 & nnn {
    goto addr;
}

# 00EE - RET; Return from a subroutine
:RET is opcode_full=0x00EE {
	SP = SP - 2;
    local tmp:2 = *:2 SP;
	return [tmp];
}

# 1nnn - JP addr; Jump to location nnn
:JP addr is opcode=0x1 & nnn {
    goto addr;
}

# 2nnn - CALL addr; Call subroutine at nnn
:CALL addr is opcode=0x2 & nnn {
    *:2 SP = addr;
    SP = SP + 2;
    call addr;
}

# 3xkk - SE Vx, byte; Skip next instruction if Vx = kk
:SE Vx, byte is opcode=0x3 & x & kk {
    if (Vx == byte) goto (inst_next + 2);
}

# 4xkk - SNE Vx, byte; Skip next instruction if Vx != kk
:SNE Vx, byte is opcode=0x4 & x & kk {
    if (Vx != byte) goto (inst_next + 2);
}

# 5xy0 - SE Vx, Vy; Skip next instruction if Vx = Vy
:SE Vx, Vy is opcode=0x5 & x & y & n=0 {
    if (Vx == Vy) goto (inst_next + 2);
}

# 6xkk - LD Vx, byte; Set Vx = kk
:LD Vx, byte is opcode=0x6 & x & kk {
    Vx = byte;
}

# 7xkk - ADD Vx, byte; Set Vx = Vx + kk
:ADD Vx, byte is opcode=0x7 & x & kk {
    Vx = Vx + byte;
}

# 8xy0 - LD Vx, Vy; Set Vx = Vy
:LD Vx, Vy is opcode=0x8 & x & y & n=0x0 {
    Vx = Vy;
}

# 8xy1 - OR Vx, Vy; Set Vx = Vx OR Vy
:OR Vx, Vy is opcode=0x8 & x & y & n=0x1 {
    Vx = Vx | Vy;
}

# 8xy2 - AND Vx, Vy; Set Vx = Vx AND Vy
:AND Vx, Vy is opcode=0x8 & x & y & n=0x2 {
    Vx = Vx & Vy;
}

# 8xy3 - XOR Vx, Vy; Set Vx = Vx XOR Vy
:XOR Vx, Vy is opcode=0x8 & x & y & n=0x3 {
    Vx = Vx ^ Vy;
}

# 8xy4 - ADD Vx, Vy; Set Vx = Vx + Vy, set VF = carry
:ADD Vx, Vy is opcode=0x8 & x & y & n=0x4 {
    Vx = Vx + Vy;
    local flag:1 = carry(Vx, Vy);
    set_flag(flag);
}

# 8xy5 - SUB Vx, Vy; Set Vx = Vx - Vy, set VF = NOT borrow
:SUB Vx, Vy is opcode=0x8 & x & y & n=0x5 {
    local flag:1 = Vx > Vy;
    set_flag(flag);
    Vx = Vx - Vy;
}

# 8xy6 - SHR Vx {, Vy}; Set Vx = Vx SHR 1
:SHR Vx, Vy is opcode=0x8 & x & y & n=0x6 {
    local flag:1 = Vx & 1;
    set_flag(flag);
    Vx = Vx >> 1;
}

# 8xy7 - SUBN Vx, Vy; Set Vx = Vy - Vx, set VF = NOT borrow
:SUBN Vx, Vy is opcode=0x8 & x & y & n=0x7 {
    local flag:1 = Vy > Vx;
    set_flag(flag);
    Vx = Vy - Vx;
}

# 8xyE - SHL Vx {, Vy}; Set Vx = Vx SHL 1
:SHL Vx, Vy is opcode=0x8 & x & y & n=0xE {
    local flag:1 = Vx & 1;
    set_flag(flag);
    Vx = Vx << 1;
}

# 9xy0 - SNE Vx, Vy; Skip next instruction if Vx != Vy
:SNE Vx, Vy is opcode=0x9 & x & y & n=0x0 {
    if (Vx != Vy) goto (inst_next + 2);
}

# Annn - LD I, addr; Set I = nnn
:LD I, addr is opcode=0xA & nnn {
    I = zext(addr);
}

# Bnnn - JP V0, addr; Jump to location nnn + V0
:JP V0, addr is opcode=0xB & nnn {
    local tmp:2 = zext(addr) + zext(V0);
    goto tmp;
}

# Cxkk - RND Vx, byte; Set Vx = random byte AND kk
:RND Vx, byte is opcode=0xC & kk {
    local tmp:1 = rand() & kk;
    Vx = tmp;
}

# Dxyn - DRW Vx, Vy, nibble; Display n-byte sprite starting at memory location I at (Vx, Vy), set VF = collision
:DRW Vx, Vy, nibble is opcode=0xD & x & y & n & I {
    local flag:1 = draw_sprite(I, Vx, Vy, nibble);
    set_flag(flag);
}

# Ex9E - SKP Vx; Skip next instruction if key with the value of Vx is pressed
:SKP Vx is opcode=0xE & x & kk=0x9E {
    local key_press:1 = get_key_press();
    if (key_press == Vx) goto (inst_next + 2);
}

# ExA1 - SKNP Vx; Skip next instruction if key with the value of Vx is not pressed
:SKNP Vx is opcode=0xE & x & kk=0xA1 {
    local key_press:1 = get_key_press();
    if (key_press != Vx) goto (inst_next + 2);
}

# Fx07 - LD Vx, DT; Set Vx = delay timer value
:LD Vx, DT is opcode=0xF & x & kk=0x07 {
    Vx = DT;
}

# Fx0A - LD Vx, K; Wait for a key press, store the value of the key in Vx
:LD Vx is opcode=0xF & x & kk=0x0A {
    local key_press:1 = get_key_press();
    Vx = key_press;
}

# Fx15 - LD DT, Vx; Set delay timer = Vx
:LD DT, Vx is opcode=0xF & x & kk=0x15 {
    DT = Vx;
}

# Fx18 - LD ST, Vx; Set sound timer = Vx
:LD ST, Vx is opcode=0xF & x & kk=0x18 {
    ST = Vx;
}

# Fx1E - ADD I, Vx; Set I = I + Vx
:ADD I, Vx is opcode=0xF & x & kk=0x1E {
    I = I + Vx;
}

# Fx29 - LD F, Vx; Set I = location of sprite for digit Vx
:LD F, Vx is opcode=0xF & x & kk=0x29 {
    # TODO
}

# Fx33 - LD B, Vx; Store BCD representation of Vx in memory locations I, I+1, and I+2
:LD B, Vx is opcode=0xF & x & kk=0x33 {
    # TODO
}

# Fx55 - LD [I], Vx; Store registers V0 through Vx in memory starting at location I
:LD [I], Vx is opcode=0xF & x & kk=0x55 {
    # TODO
}

# Fx65 - LD Vx, [I]; Read registers V0 through Vx from memory starting at location I
:LD Vx, [I] is opcode=0xF & x & kk=0x65 {
    # TODO
}

